#!/usr/bin/env ruby

require "rubygems"
require "bundler"

Bundler.require :runtime

require 'ostruct'

module Patches
	refine String do
		def strftime
			DateTime.iso8601(self).strftime('%H:%M')
		end

		def subzh
			gsub('ZÃ¼rich', 'Zh').
					gsub('Bahnhof', 'Bhf')
		end

		def subcon
			tokens = split(' ')
			tokens[0][-1] + ' ' + tokens[1]
		end
	end
end

# https://gist.github.com/pmarreck/5349411
module HashToOpenstruct
	def to_ostruct
		OpenStruct.new(self).tap do |o|
			each.with_object(o) do |(k,v), o|
				o.send(:"#{k}=", v.to_ostruct) if v.is_a?(Hash) || v.is_a?(Array)
			end
		end
	end
end

class Array
	def to_ostruct
		map { |_|
			if _.is_a?(Hash) || _.is_a?(Array)
				_.to_ostruct
			else
				_
			end
		}
	end
end

# TODO
# one command
# departure & arrival time
# autocomplete
# zone info (if not 110)
#

Hash.include HashToOpenstruct

using Patches

include GLI::App

program_desc 'ZVV and Swiss Open Data public transport utility'

version Zvv::Cli::VERSION
subcommand_option_handling :normal

desc 'Find connection between two destinations'
arg_name 'from to'
command :connection do |c|
	c.action do |global_options, options, args|

		# Your command logic here

		# If you have any errors, just raise them
		# raise "that command made no sense"

		connections = Transprt.connections(from: args.first, to: args.last).to_ostruct
		connections.each_with_index do |c, i|
			#byebug
			puts ("%s %s ---> %s %s" % [c.from.station.name, c.from.departure.strftime, c.to.station.name, c.to.arrival.strftime]).subzh
			c.sections.each do |s|
				if s.walk
					puts ("Walk (%s) to %s" % [s.walk.duration, s.departure.station.name]).subzh.light_black
				else
					#puts s.inspect
					puts ("%s %s -- %s --> %s %s" % [s.departure.station.name, s.departure.departure.strftime, s.journey.name.subcon, s.arrival.station.name, s.arrival.arrival.strftime]).subzh.light_black
				end
			end
			puts unless i == connections.length - 1
		end
	end
end

default_command :connection
exit run(ARGV)
